{"componentChunkName":"component---src-templates-blog-post-js","path":"/mocking-in-swift/","result":{"data":{"site":{"siteMetadata":{"title":"Felipe Mendes"}},"markdownRemark":{"id":"22ddd10a-46dc-5aff-a15b-f5d1bdbb321e","excerpt":"Durante o desenvolvimento, frequentemente nos deparamos em situações para escrever código . Esse é o tipo de código que você prefere não escrever à mão e, na…","html":"<p>Durante o desenvolvimento, frequentemente nos deparamos em situações para escrever código <code class=\"language-text\">boilerplate</code>. Esse é o tipo de código que você prefere não escrever à mão e, na maioria das vezes, acaba copiando e colando de um modelo existente. Essa atitude, por mais trivial que pareça, pode levar a certos erros e até mesmo causar falhas durante a execução do código. Para solucionar essa tarefa, a geração automática de código pode ser útil. Geradores de código permitem que seja feita a criação do código chato e repetitivo de forma automática e no fim torna o aplicativo mais confiável.</p>\n<p>Existem diversas maneiras de aplicar geradores de código para auxiliar o desenvolvimento. Alguns dos cenários mais comuns são para geração de Injeção de Dependência, recursos (como imagens, <code class=\"language-text\">strings</code> localizadas, entre outros) e <code class=\"language-text\">mock</code> para testes.</p>\n<p>Neste post, vamos entender um pouco como funcionam os gerados de <code class=\"language-text\">mock</code> para nossos testes em <code class=\"language-text\">Swift</code>. Vale lembrar que a própria linguagem possui formas que eliminam a geração de código para certas tarefas. Tais como os protocolos <code class=\"language-text\">Codable</code>, <code class=\"language-text\">Equatable</code>, <code class=\"language-text\">Hashable</code> e <code class=\"language-text\">CaseIterable</code>.</p>\n<p><code class=\"language-text\">Swift</code> é uma linguagem estática e <code class=\"language-text\">type safety</code>, o que é ótimo, mas também quer dizer que o <code class=\"language-text\">runtime</code> é muito limitado. Não é possível criar ou modificar dinamicamente o comportamento de uma classe em tempo de execução. Portanto, testes unitários com <code class=\"language-text\">mocks</code> podem ser tornar uma tarefa árdua em alguns momentos.</p>\n<h2>O que são <code class=\"language-text\">mocks</code>?</h2>\n<p>Classes que servem para fazer uma substituição de uma interface externa, como uma <code class=\"language-text\">API</code>, por exemplo. Essas classes ajudam a verificar determinados comportamentos, tais como, saber se um método foi invocado ou não, quantas vezes foi chamado e quais parâmetros foram informados.</p>\n<h2>Quando usar <code class=\"language-text\">mocks</code>?</h2>\n<p>Ao execurtarmos os testes unitários queremos que a execução seja mais rápida possível e que não haja nenhum tipo de interferência externa que impacte os comportamentos. Dessa forma, <code class=\"language-text\">mocks</code> elimiam as dependências externas como: <code class=\"language-text\">APIs</code>, bibliotecas, camada de serviços, entre outras. Além disso, os <code class=\"language-text\">mocks</code> facilitam a simulação de cenários para os diversos comportamentos possíveis.</p>\n<h2>Gerador de código</h2>\n<p>Gerador de código elimina do desenvolvedor a responsabilidade de criar códigos repetitivos. Assim o time consegue aumentar a produtividade e centralizar todas as energias na entrega de valor, ou seja, focar no que realmente interessa para o negócio: produzir valor.</p>\n<p>A economia de tempo é o principal motivo ao escolher uma ferramenta de geração de código. Outro ponto é a consistência que é criada no código. Como o código é gerado automaticamente haverá um padrão em todos os casos.</p>\n<p>No desenvolvimento Apple, uma solução comum, herdada do <code class=\"language-text\">Objective-C</code>, é utilizar a biblioteca <code class=\"language-text\">OCMock</code>. Porém, para o desenvolvimento moderno encontramos algumas limitações como: os objetos precisam ser subclasse de <code class=\"language-text\">NSObject</code>; necessário ter o atríbuto <code class=\"language-text\">@objc</code> nos métodos de sobreposição; não suporta tipos genéricos; e não é aplicável em métodos de classe.</p>\n<p>Felizmente, existem diversas ferramentas modernas que geram automaticamente os objetos <code class=\"language-text\">mocks</code> para nossos testes. As opções mais comuns são:</p>\n<ul>\n<li>Mockolo</li>\n<li>Sourcery</li>\n<li>SwiftyMocky</li>\n</ul>\n<h3>Mockolo</h3>\n<p>É um <code class=\"language-text\">framework</code>, <code class=\"language-text\">open-source</code> desenvolvido pela Uber para oferecer uma maneira rápida e fácil de gerar automaticamente objetos <code class=\"language-text\">mocks</code>. Um dos principais objetivos do <strong>Mockolo</strong> é o desempenho rápido. Ao contrário das outras alternativas, o <strong>Mockolo</strong> fornece a geração de <code class=\"language-text\">mocks</code> de alto desempenho e escalonável por meio de uma ferramenta de linha de comando leve, de modo que pode ser executado como parte do <code class=\"language-text\">Linter</code> ou do <code class=\"language-text\">Build</code> da aplicação.</p>\n<p>A motivação da Uber foi desenvolvedor um projeto que seja rápido o suficiente para atender uma grande base de código. Nos seus projetos internos que possui mais de 2M <code class=\"language-text\">LoC</code> e mais de 10K de protocolos, os demais geradores de código demoravam várias horas e, mesmo com o cache ativado, demoravam vários minutos. Com o <strong>Mockolo</strong> a geração dos códigos ficou na casa dos segundos.</p>\n<p>Outro objetivo é permitir flexibilidade no uso ou sobreposição de tipos. Isso permite o uso de alguns dos recursos que requerem uma análise mais profunda, como protocolos com tipos associados, para serem mais simples, diretos e menos frágeis.</p>\n<blockquote>\n<p>O projeto no GitHub possui um <code class=\"language-text\">disclaimer</code> alertando que o projeto pode conter <code class=\"language-text\">APIs</code> instáveis que podem não estar prontas para o uso geral. E suporte dos contribuidores e/ou novas <code class=\"language-text\">releases</code> podem ser limitados.</p>\n</blockquote>\n<p>O <strong>Mockolo</strong> pode ser executado diretamente pela linha de comando. Para executá-lo, é necessário informar o arquivo ou diretório de origem e destino de saída do <code class=\"language-text\">mock</code>. O executável irá buscar todos os arquivos que possuem o marcador <code class=\"language-text\">@mockable</code> para realizar a geração.</p>\n<h3>Sourcery</h3>\n<p>É um gerador de código construído sobre o <code class=\"language-text\">SwiftSyntax</code> da Apple. Ele estende as abstrações da linguagem para permitir a criação de código <code class=\"language-text\">boilerplate</code> automaticamente.</p>\n<p>É usado em mais de 40.000 projetos no iOS e no macOS. Sua adoção massiva pela comunidade foi um dos fatores que levaram a própria Apple a implementar diversas melhorias na linguagem <code class=\"language-text\">Swift</code>.</p>\n<p><strong>Sourcery</strong> vai além da geração de código <code class=\"language-text\">mock</code> e pode ser aplicado em diversas situações do dia a dia. Alguns usos mais comuns são:</p>\n<ul>\n<li>Equality e Hashing</li>\n<li>Enum cases e Counts</li>\n<li>Mocks</li>\n<li>Stubs</li>\n<li>Decorators</li>\n<li>Codable</li>\n<li>UI</li>\n</ul>\n<p>O <code class=\"language-text\">framework</code> pode ser utilizado tanto via linha de comando quanto instalando diretamente no projeto. Para a geração de <code class=\"language-text\">mocks</code>, é necessário implementar o protocolo <code class=\"language-text\">AutoMockable</code> ou inserir a anotação <code class=\"language-text\">AutoMockable</code>.</p>\n<h3>SwiftyMocky</h3>\n<p><strong>SwiftyMocky</strong> é um <code class=\"language-text\">framework</code> leve e fortemente tipado que possui uma experiência de teste unitários mais próxima <code class=\"language-text\">Mockito</code>, usado no desenvolvimento <code class=\"language-text\">Java</code>. A biblioteca abstrai o comportamento do <strong>Sourcery</strong>, que verifica o código-fonte e gera apenas os códigos <code class=\"language-text\">mocks</code>.</p>\n<p>A ideia do <strong>SwiftyMocky</strong> é simular automaticamente os protocolos Swift. As principais características são:</p>\n<ul>\n<li>Sintaxe fácil, utilizando todo o poder do <code class=\"language-text\">auto-complete</code></li>\n<li>Suporta tipos genéricos</li>\n<li>Maneira de especificar o retorno do <code class=\"language-text\">mock</code></li>\n<li>Possibilidade de especificar diferentes retornos para diferentes atributos</li>\n</ul>\n<p>Como abstrai do <strong>Sourcery</strong>, ao executar a geração dos <code class=\"language-text\">mocks</code>, o executável irá buscar em todos os arquivos o marcador <code class=\"language-text\">AutoMockable</code>.</p>","frontmatter":{"title":"Mocking in Swift","date":"19 maio, 2021","description":""}},"previous":{"fields":{"slug":"/pipeline-ios/"},"frontmatter":{"title":"Pipeline de desenvolvimento no Xcode"}},"next":{"fields":{"slug":"/multiple-variadic-parameters/"},"frontmatter":{"title":"Multiple Variadic Parameters"}}},"pageContext":{"id":"22ddd10a-46dc-5aff-a15b-f5d1bdbb321e","previousPostId":"87a71028-28b2-5fe6-a3e5-9e913ef8d39b","nextPostId":"402d0247-dd3d-5635-b9b3-3d881a2216b1"}},"staticQueryHashes":["1344965497","2841359383"]}