{"componentChunkName":"component---src-templates-blog-post-js","path":"/struct-vs-class/","result":{"data":{"site":{"siteMetadata":{"title":"Felipe Mendes"}},"markdownRemark":{"id":"540ca7f2-7f39-5fdc-9c32-3a8d56973367","excerpt":"Swift fornece vários recursos que tornam as Structs melhores que as Classes em diversas situações, no entanto muitos desenvolvedores têm dificuldades em…","html":"<p>Swift fornece vários recursos que tornam as Structs melhores que as Classes em diversas situações, no entanto muitos desenvolvedores têm dificuldades em entender ou em escolher a melhor opção entre ambos. A principal característica de Strutcs é a imutabilidade, e na dúvida a melhor opção é começar com uma Struct e se durante o desenvolvimento surgir a necessidade de criar cópias independentes ou utilizar os dados em múltiplas <code class=\"language-text\">threads</code> basta alterar a declaração para Class.</p>\n<h3>Comparando Struct e Class</h3>\n<p>Struct e Class no Swift têm muitas coisas em comum. Ambos possuem:</p>\n<ul>\n<li>Propriedades que armazenam valores</li>\n<li>Métodos com funcionalidades</li>\n<li>Subíndices para fornecer acesso aos seus valores usando a sintaxe subscrita</li>\n<li>Inicializadores (init) para configurar seu estado inicial</li>\n<li>Possibilidade de ser estendido para expandir sua funcionalidade além de uma implementação padrão</li>\n<li>Conformidade com protocolos para fornecer funcionalidade padrão de um certo tipo</li>\n</ul>\n<p>Porém as Classes têm recursos adicionais que as Structs não têm, como:</p>\n<ul>\n<li>Herança para obter características de outra classe</li>\n<li>Conversão de tipos para verificar e interpretar o tipo de uma instância de classe no tempo de execução</li>\n<li>Desinicializadores (deinit) para desalocar instâncias quando não mais são utilizadas</li>\n<li>Contagem de referência que permite mais de uma referência a uma instância de classe</li>\n</ul>\n<p>Outra diferença importante entre ambos é o tipo de cada. <strong>Structs são Value Types e Classes são Reference Types</strong>.</p>\n<h3>O que são Value Types e Reference Types?</h3>\n<p>Tipos em Swift são categorizados em duas situções: primeiro <strong>value types</strong> onde cada instância armazena uma <strong>cópia única</strong> dos dados. Além de <code class=\"language-text\">struct</code> , <code class=\"language-text\">enums</code>, <code class=\"language-text\">tuplas</code> e <code class=\"language-text\">primitivos</code> são value types. E segundo <strong>reference types</strong> onde as instâncias compartilham a <strong>única cópia</strong> dos dados, normalmente definido por uma <code class=\"language-text\">class</code>.</p>\n<p>A característica básica de um <strong>value type</strong> é que o processo de <strong>cópia</strong> cria uma instância independente com sua própria cópia exclusiva de seus dados.</p>\n<h3>Value Types e Reference Types na memória</h3>\n<p>Quando uma <strong>reference type</strong> é criada, como uma Classe, o sistema armazena a instância real em uma região da memória conhecida como <strong>Heap</strong> (porção menor da memória). Enquanto, as instâncias de <strong>value type</strong>, como uma Struct, permanecem em uma região da memória chamada <strong>Stack</strong> (porção maior da memória).</p>\n<h4>Exemplo de value type</h4>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">var</span> data<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> primary <span class=\"token operator\">=</span> <span class=\"token class-name\">Data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> secondary <span class=\"token operator\">=</span> primary <span class=\"token comment\">// primary é copiado para secondary</span>\nprimary<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token number\">20</span> <span class=\"token comment\">// altera valor do primary, não do secondary</span>\n\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span>primary<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token comment\">// retorna \"20\"</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span>secondary<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token comment\">// retorna \"10\"</span></code></pre></div>\n<p>Já o processo de <strong>cópia</strong> em <strong>reference type</strong> cria uma instância compartilhada. Depois de uma cópia, duas variáveis referem-se a uma única instância dos dados, com isso, modificar os dados na segunda variável também afeta o original.</p>\n<h4>Exemplo de reference type</h4>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> data<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> primary <span class=\"token operator\">=</span> <span class=\"token class-name\">Data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> secondary <span class=\"token operator\">=</span> primary <span class=\"token comment\">// primary é copiado para secondary</span>\nprimary<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token number\">20</span> <span class=\"token comment\">// altera a instância referenciada por primary (e secondary)</span>\n\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span>primary<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\t<span class=\"token comment\">// retorna \"20\"</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span>secondary<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\t<span class=\"token comment\">// retorna \"20\"</span></code></pre></div>\n<h3>Motivos para utilizar Value Types</h3>\n<ol>\n<li>Eficiência\nA alocação de memória em <code class=\"language-text\">Reference Types</code> é mais custoso comparado com <code class=\"language-text\">Value Types</code>. Além disso, a fim de liberar a memória alocada, o sistema operacional precisa manter o controle da contagem de referência e, quando a contagem é zero, a memória é liberada. Essa sobrecarga não acontece com <code class=\"language-text\">Value Types</code> que levam à criação e à cópia eficiente da instância.</li>\n<li>Código previsível\nCom <code class=\"language-text\">Reference Type</code> não temos certeza em relação ao conteúdo da instância criado, visto que qualquer parte do código pode ser modificada usando qualquer outra referência. Como as instâncias de <code class=\"language-text\">Value Types</code> são copiadas na atribuição não precisamos nos preocupar se o comportamento de outras partes do código irão afetar demais instâncias.</li>\n<li>Segurança nas Threads\nInstâncias de <code class=\"language-text\">Value Types</code> são mais seguras em ambientes de multi-thread pois não precisamos nos preocupar se o estado de uma instância está sendo utilizado em outras threads.</li>\n<li>Evita Memory Leak\nSwift utilizado o <a href=\"https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html\">ARC</a> para deslocar instância de <code class=\"language-text\">Reference Types</code>, apesar de eficiente ainda pode causar erros durante a execução. Porém este problema não ocorre em <code class=\"language-text\">Value Types</code> pois não há referências como <code class=\"language-text\">Reference Types</code>.</li>\n</ol>","frontmatter":{"title":"Struct vs Class","date":"25 fevereiro, 2019","description":""}},"previous":{"fields":{"slug":"/optionals/"},"frontmatter":{"title":"Optionals"}},"next":{"fields":{"slug":"/lazy-var/"},"frontmatter":{"title":"Lazy Var"}}},"pageContext":{"id":"540ca7f2-7f39-5fdc-9c32-3a8d56973367","previousPostId":"cf33c1d9-dd07-56b1-8cef-b0ca68bc5614","nextPostId":"fd80836f-1cc9-5d16-96d4-4bc4594f9a5b"}},"staticQueryHashes":["1344965497","2841359383"]}